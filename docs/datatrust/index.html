<!DOCTYPE html>





<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Datatrust
  
 | The Computable Book</title>



<link rel="stylesheet" href="../../book.min.f4161f5e2de53a2e927f51df1611323a2a12cccb2681f23cb6fc3517852e8643.css">


<link rel="icon" href="../../favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://computablelabs.github.io/compspec/">The Computable Book</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2f datatrust\2f "] {
      color: #0b3a53;
  }
  </style>

<ul>
<li><a href="../../"><strong>Introduction</strong></a></li>
<li><a href="../../docs/contracts/">Contracts</a></li>
<li><a href="../../docs/ethertoken/">Ether Token</a></li>
<li><a href="../../docs/markettoken/">Market Token</a></li>
<li><a href="../../docs/voting/">Voting</a></li>
<li><a href="../../docs/listings/">Listings</a></li>
<li><a href="../../docs/reserve/">Reserve</a></li>
<li><a href="../../docs/datatrust/">Datatrusts</a></li>
<li><a href="../../docs/parameters/">Market Parameters</a></li>
<li><a href="../../docs/capi/">CAPI</a></li>
<li><a href="../../docs/libraries/">Developer Libraries</a></li>
<li><a href="../../docs/userjourney/">User Journeys</a></li>
<li><a href="../../docs/attacks/">Attacks</a></li>
<li><a href="../../docs/continuing/">Continuing Your Journey</a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="../../svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Datatrust
  
</strong>
</header>

      
<article class="markdown">

<h1 id="the-datatrust">The Datatrust</h1>

<p>Alright, we&rsquo;ve now talked through a whole set of the
smart contracts in the system. You&rsquo;ve learned about
listings, the reserve, voting, and the tokens. Now onto
the datatrust.  There&rsquo;s something tricky we&rsquo;re going to
have to wrestle with. Fundamentally, a datatrust is a
piece of software that has to run off-chain (in a
<a href="../capi/index.html">future chapter</a> you&rsquo;ll learn about
the specification for this off-chain software) since it
needs to store and serve potentially very large pieces
of data. How can we possibly bound the behavior of this software from the on-chain world?</p>

<p>In general, there&rsquo;s a gulf between the on-chain and
off-chain worlds in smart contract systems. It&rsquo;s hard
to reach between the two realms. In particular, it&rsquo;s
extraordinarily hard to prove facts about the off-chain
world from on-chain. This means that for now, the
on-chain <code>Datatrust</code> contract can only loosely control
the behavior of the off-chain datatrust software. We&rsquo;re
actively
<a href="https://forum.computable.io/t/towards-atomic-delivery-of-data/62">researching</a>
cryptographic techniques to remedy this situation, but
for now this means that the datatrust is a semi-trusted
part of the system. This means that each data market
has to trust that the operator of its datatrust will
behave correctly. This isn&rsquo;t necessarily unreasonable
though. But it basically means the creator of a data
market should do some legwork to make sure the
datatrust is run securely, perhaps by running the
datatrust software themselves.</p>

<p>Let&rsquo;s return to the subject though. In the next few sections, we&rsquo;ll talk through some of on-chain guardrails we want to design around the datatrust.</p>

<h2 id="voting-to-add-or-replace-a-datatrust">Voting to Add or Replace a Datatrust</h2>

<p>Each data market has only one datatrust. It makes sense that voting in this datatrust would require a stakeholder vote. If we can vote in a datatrust, we can also replace it, which serves as a primitive guard on datatrust behavior (behave badly enough and you&rsquo;ll be voted out).</p>

<h2 id="listing-handling">Listing handling</h2>

<p>The Datatrust is responsible for storing the off-chain
data associated with listings. Listing candidates must
convey their off-chain candidate data to the Datatrust
node in order to be listed. The Datatrust acknowledges
receipt of this listing data by setting the <code>data_hash</code>
for a given listing on-chain. If this acknowledgement
is not registered on-chain, the listing candidate
cannot become a listing. This acknowledgement is done with the <code>Datatrust.setDataHash()</code> function:</p>

<pre><code>@public
def setDataHash(listing: bytes32, data: bytes32):
  &quot;&quot;&quot;
  @notice Allow a registered backend to set the data_hash for a given listing
  @param listing The hashed identifier of a current market listing
  @param data The hashed data held by the backend for said listing
  &quot;&quot;&quot;
  assert msg.sender == self.backend_address
  self.data_hashes[listing] = data
</code></pre>

<p>This function simply cheks that the authorized
datatrust (which is at <code>self.backend_address</code>) called
it, then sets a hash for the listing. This is used by
<code>Listing.resovleApplication()</code> to check that the
datatrust has affirmed that the data for a listing
candidate was received before allowing it to be listed.</p>

<h2 id="listing-utilization-records">Listing Utilization Records</h2>

<p>The datatrust is responsible for maintaining a record of
which listings have been accessed by buyers. Remember
from the <a href="../listings/index.html">listings chapter</a>
that a buyer of data only purchases a set number of
bytes. The datatrust is responsible for providing the
purchaser access to listings they desire, while
checking that the buyer has enough budget left. The
total number of bytes accessed from a given listing is
tracked on-chain in the <code>Datatrust.bytes_accessed</code>
field:</p>

<pre><code>bytes_accessed: map(bytes32, uint256) # maps a listing to its currently unclaimed bytes accessed
</code></pre>

<p>There&rsquo;s another mapping <code>Datatrust.bytes_purchased</code> which tracks the total number of bytes purchased. This is updated by <code>Datatrust.requestDelivery</code> as you saw in the <a href="../listings/index.html">listings chapter</a>:</p>

<pre><code>bytes_purchased: map(address, uint256) # maps user-address to total amount of bytes purchased
</code></pre>

<p>After a listing has been accessed by a buyer, the
datatrust has to report this on-chain by calling
<code>Datatrust.listingAccessed</code></p>

<pre><code>@public
def listingAccessed(listing: bytes32, delivery: bytes32, amount: uint256):
  &quot;&quot;&quot;
  @notice Allow a backend to record the access of a listing, thus fulfulling part of a delivery.
  @dev Only a registered backend may call. Enforce that the claimed listing exists.
  @param listing The listing that was accessed
  @param delivery Which delivery object this access was for
  @param amount How many bytes were accessed
  &quot;&quot;&quot;
  assert msg.sender == self.backend_address
  assert self.data_hashes[listing] != EMPTY_BYTES32
  # this can be claimed later by the listing owner, and are subtractive to bytes_purchased
  self.bytes_accessed[listing] += amount
  self.bytes_purchased[self.deliveries[delivery].owner] -= amount
  # bytes_delivered must eq (or exceed) bytes_requested in order for a datatrust to claim delivery
  self.deliveries[delivery].bytes_delivered += amount
</code></pre>

<p>This function call increments <code>self.bytes_accessed</code> for
this listing while decrementing <code>self.bytes_purchased</code>
by the same amount. The listing owner now has some
rewards they can claim. To do this claiming, they need
to call <code>Datatrust.bytesAccessedClaimed</code>:</p>

<pre><code>@public
def bytesAccessedClaimed(hash: bytes32, fee: wei_value):
  &quot;&quot;&quot;
  @notice Called by the Listing contract when a maker claims their listing access rewards
  @param hash The listing identifier
  @param fee Amount of ether token to transfer to the reserve
  &quot;&quot;&quot;
  assert msg.sender == self.listing_address
  clear(self.bytes_accessed[hash]) # clear before paying
  self.ether_token.transfer(self.reserve_address, fee)
  # NOTE bytes accessed claimed event published by Listing contract
</code></pre>

<p>This function simply clears the backlog of
<code>bytes_accessed</code> for this listing owner and unlocks
their fair share of the purchase fee.</p>

<p>You might reasonably ask why a datatrust operator is
motivated to do all this work reporting which listings
were accessed. Well, the only way the datatrust gets
its fair payment is after it&rsquo;s finished reporting all
the listings that were accessed. To claim its payment,
the datatrust operator has to call
<code>Datatrust.delivered</code>:</p>

<pre><code>@public
def delivered(delivery: bytes32, url: bytes32):
  &quot;&quot;&quot;
  @notice Allow a backend to collect its payment.
  @dev We check that a backend has delivered, at least, the amount of bytes requested.
  NOTE: bytes_requested is the multiplier for backend payment.
  @param delivery Identifier of the delivery in question
  @param url A hash of the URL that the backend delivered to
  &quot;&quot;&quot;
  assert msg.sender == self.backend_address
  owner: address = self.deliveries[delivery].owner
  requested: uint256 = self.deliveries[delivery].bytes_requested
  assert self.deliveries[delivery].bytes_delivered &gt;= requested
  # clear the delivery record first
  clear(self.deliveries[delivery])
  # now pay the datatrust from the banked delivery request
  back_fee: wei_value = (self.parameterizer.getCostPerByte() * requested * self.parameterizer.getBackendPayment()) / 100
  self.ether_token.transfer(self.backend_address, back_fee)
  log.Delivered(delivery, owner, url)
</code></pre>

<p>This function checks that the full delivery has been
made, then pays out the datatrust operator. This
provides an on-chain check on the datatrust operator&rsquo;s
behavior and forces it to do some work before it gets
paid.</p>

<h2 id="proposing-a-new-datatrust">Proposing a new datatrust.</h2>

<p>An interested party can propose itself as a new
datatrust candidate by calling <code>Datatrust.register()</code></p>

<pre><code>@public
def register(url: string[128]):
  &quot;&quot;&quot;
  @notice Allow a backend to register as a candidate
  @param url The location of this backend
  &quot;&quot;&quot;
</code></pre>

<p>(TODO: There&rsquo;s currently a bug in register uncovered in audit. Add full code once bugfix is in place)</p>

<p>Calling this method triggers a vote. If the vote
passes, then this this party becomes the new datatrust
for the system. This means that the old datatrust (if
there was one), is essentially kicked out.</p>

<h2 id="last-thoughts">Last Thoughts</h2>

<p>At this point, we&rsquo;ve discussed all the major smart
contract systems in Computable, with the exception of
the <code>Parameterizer</code> which sets market parameters. We&rsquo;ll
hit this system in the next chapter.</p>

<div style="text-align: right"> <a href="../../docs/parameters">Next Chapter</a> </div>
</article>

      
<div class="book-footer justify-between">
  
  <div>
    
    <a href="https://github.com/computablelabs/compspec/commit/29df2b60cf154566364112d88e4e72ba301549d9" title='Last modified Jul 11, 2019 by Bharath Ramsundar' target="_blank" rel="noopener">
      <img src="../../svg/calendar.svg" alt="Changed" /> Jul 11, 2019
    </a>
  </div>
  
  
  <div>
    <a href="https://github.com/computablelabs/compspec/edit/master/docs/datatrust.md" target="_blank" rel="noopener">
      <img src="../../svg/edit.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  

  <aside class="book-toc level-6 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#the-datatrust">The Datatrust</a>
<ul>
<li><a href="#voting-to-add-or-replace-a-datatrust">Voting to Add or Replace a Datatrust</a></li>
<li><a href="#listing-handling">Listing handling</a></li>
<li><a href="#listing-utilization-records">Listing Utilization Records</a></li>
<li><a href="#proposing-a-new-datatrust">Proposing a new datatrust.</a></li>
<li><a href="#last-thoughts">Last Thoughts</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
