<!DOCTYPE html>





<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Voting
  
 | Computable Spec</title>



<link rel="stylesheet" href="../../book.min.f4161f5e2de53a2e927f51df1611323a2a12cccb2681f23cb6fc3517852e8643.css">


<link rel="icon" href="../../favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://computablelabs.github.io/compspec/">Computable Spec</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2fvoting\2f "] {
      color: #0b3a53;
  }
  </style>

<ul>
<li><a href="../../"><strong>Introduction</strong></a></li>
<li><a href="../../docs/contracts/">Contracts</a></li>
<li><a href="../../docs/ethertoken/">Ether Token</a></li>
<li><a href="../../docs/markettoken/">Market Token</a></li>
<li><a href="../../docs/voting/">Voting</a></li>
<li><a href="../../docs/listings/">Listings</a></li>
<li><a href="../../docs/reserve/">Reserve</a></li>
<li><a href="../../docs/datatrust/">Datatrusts</a></li>
<li><a href="../../docs/parameters/">Market Parameters</a></li>
<li><a href="../../docs/capi/">The Computable API</a></li>
<li><a href="../../docs/attacks/">Attacks</a></li>
<li><a href="../../docs/userjourney/">User Journeys</a></li>
<li><a href="../../docs/continuing/">Continuing Your Journey</a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="../../svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Voting
  
</strong>
</header>

      
<article class="markdown">

<h1 id="voting">Voting</h1>

<p>As we&rsquo;ve mentioned previously, <code>MarketToken</code>s are
analogous to company shares. Just as company
shareholders can vote on some company decisions,
<code>MarketToken</code> stakeholders are allowed to vote on some
data market governance questions.  In fact, all major
decisions in the data market are made by token holder
vote.  These decisions include which new listing
candidates (a &ldquo;listing candidate&rdquo; is a chunk of data
which has not yet been confirmed as a listing in the
market) should be confirmed as listings, which
challenged listings should be removed from the market
(we&rsquo;ll say more about challenges later), what changes
should be made to the <code>Parameterizer</code> parameters (which
govern the market&rsquo;s behavior; more on this later), and
who the datatrust operator should be. In this chapter,
we&rsquo;ll introduce you to the fundamentals of the voting
system and describe the basics of on-chain Computable
governance.</p>

<h2 id="candidates-candidates-candidates">Candidates, Candidates, Candidates</h2>

<p>All voting is done on &ldquo;candidates.&rdquo; Think of a
candidate as governance question brought up for
referendum. There are a number of different types of
candidates:</p>

<h3 id="listing-candidates">Listing candidates</h3>

<p>A proposal to add a new listing to the data market is a
&ldquo;listing candidate.&rdquo; A maker (a data contributor) who
has gathered some interesting data, creates a listing
candidate to propose that their data should be added to
the data market. If this candidate is accepted, the
maker is rewarded with <code>listing_reward</code>, a tranche of
newly minted <code>MarketToken</code>.</p>

<p>Here, the vote serves as a gating mechanism to prevent
fraudulent data from entering the market. It also
allows for some quality control checks on data to be
performed by any interested parties.</p>

<h3 id="challenge-candidate">Challenge candidate</h3>

<p>A proposal to remove an existing listing from the data
market. Sometimes, the listing process will allow a bad
listing (with poor data perhaps) to slip through. In
this case, we need a mechanism to allow for clean-up
and removal of this data. The challenge mechanism
allows for this sort of cleanup. An interested party
can challenge a listing they believe to be fraudulent.
If the vote succeeds, this listing is removed from the
market.</p>

<p>To prevent nuisance challenges, creating a challenge
requires locking up some <code>MarketToken</code>. The amount to
be locked up is governed by the <code>stake</code> parameter set
in the <code>Parameterizer</code>. If the challenge is rejected
(judged by stakeholders to be frivolous), then the
listing owner is rewarded for the trouble they faced.
For this reason, challenges will likely be relatively
uncommon since there&rsquo;s a risk of losing funds.</p>

<p>As a second complication, you might ask, what happens
to the <code>MarketToken</code> that was minted in the case of a
successful challenge that removes the associated
listing? The answer is absolutely nothing. If you
succeeded in pulling a fast one on the data market, you
are allowed to walk with the funds. This choice was
made to keep the contract complexity to manageable
levels, since having &ldquo;lockups&rdquo; to prevent this
situation would add quite a bit of extra code.</p>

<h3 id="reparameterization-candidate">Reparameterization candidate</h3>

<p>A proposal to change the parameters of the data market. We&rsquo;ll say more about the parameters that can be altered in a future chapter.</p>

<h3 id="datatrust-candidate">Datatrust candidate</h3>

<p>A proposal to change the datatrust used for the market.
If a datatrust operator is misbehaving, this mechanism
allows for the datatrust to be replaced if necessary.
However, it&rsquo;s worth nothing that the datatrust has
considerable power in this version of the Computable
protocol, so this facility is something of a &ldquo;nuclear
option&rdquo; only to be used if other measures aren&rsquo;t
panning out.</p>

<h2 id="the-voting-code">The voting code</h2>

<p>On-chain, a candidate is represented by a <code>Candidate</code>
struct:</p>

<pre><code>struct Candidate:
  kind: uint256 # one of [1,2,3,4] representing an
application, challenge, reparam or registration
respectively
  owner: address
  stake: wei_value
  vote_by: timestamp
  yea: uint256
  nay: uint256
</code></pre>

<p>Let&rsquo;s quickly review the fields of this struct. The
<code>owner</code> is the Ethereum address of the candidate
proposer. As a quick note, the Computable protocol
doesn&rsquo;t know anything about humans. The only entities
that it knows about are Ethereum addresses. What is an
address you might ask? It&rsquo;s simply a 64 character hex
string that uniquely identifies some entity on
Ethereum. This entity could be a human, a smart
contract, a consortium or anything. All the
participants in the Computable protocol we&rsquo;ve talked
about (makers, stakeholders, datatrust operators) are
all Ethereum addresses. Which means that participants
in the Computable protocol aren&rsquo;t necessarily humans,
although the could be of course.</p>

<p>Returning to the discussion, the <code>stake</code> is the amount
of <code>MarketToken</code> that must be placed as stake to vote
for/against this candidate. (We&rsquo;ll say more about this
shortly). <code>vote_by</code> is how long the the voting poll
will be open for this candidate. And <code>yea</code> and <code>nay</code>
count the number of votes in favor and opposing this
candidate.</p>

<h2 id="voting-1">Voting</h2>

<p>The voting system is quite simple. To place a vote, a
stakeholder simply locks up <code>Candidate.stake</code> of
<code>MarketToken</code>.</p>

<pre><code>@public
def vote(hash: bytes32, option: uint256):
  &quot;&quot;&quot;
  @notice Cast a vote for a given candidate
  @dev User mush have approved market token to spend on
their behalf
  @param hash The candidate identifier
  @param option Yea (1) or Nay (!1)
  &quot;&quot;&quot;
  assert self.candidates[hash].owner != ZERO_ADDRESS
  assert self.candidates[hash].vote_by &gt;
block.timestamp
  stake: wei_value = self.candidates[hash].stake
  self.market_token.transferFrom(msg.sender, self,
stake)
  self.stakes[msg.sender][hash] += stake
  if option == 1:
    self.candidates[hash].yea += 1
  else:
    self.candidates[hash].nay += 1
  log.Voted(hash, msg.sender)
</code></pre>

<p>A stakeholder may vote as many times as they wish, at
the cost of locking up more stake. Note that this makes
a data market an explicit plutocracy: larger
stakeholders in the data market explicitly have greater
voting power. While the downsides of plutocratic
systems are well known, it&rsquo;s worth remembering that
each data market is a relatively local system. It&rsquo;s not
unfair that large stakeholders have more say in how its
run (just as owners of a business have more say in its
operations than third parties).</p>

<p>The vote passes if the proportion of <code>yea</code> votes is
greater than the <code>plurality</code> parameter.</p>

<pre><code>@public
@constant
def didPass(hash: bytes32, plurality: uint256) -&gt; bool:
  &quot;&quot;&quot;
  @notice Return a bool indicating whether a given
candidate recieved enough votes to exceed the plurality
  @dev The poll must be closed. Also we cover the
corner case that no one voted.
  @return bool
  &quot;&quot;&quot;
  assert self.candidates[hash].owner != ZERO_ADDRESS
  assert self.candidates[hash].vote_by &lt;
block.timestamp
  yea: uint256 = self.candidates[hash].yea
  total: uint256 = yea + self.candidates[hash].nay
  # edge case that no one voted
  if total == 0:
    # theoretically a market could have a 0 plurality
    return plurality == 0
  else:
    return ((yea * 100) / total) &gt;= plurality
</code></pre>

<p>This simple voting system has the advantage of being
easy to understand. However, the trade-off is that this
simplicity allows for some sophisticated vote
manipulation techniques to be feasible. We discuss such
attacks in greater detail later.</p>

<p><a href="../listings/index.html">Next Chapter</a></p>
</article>

      
<div class="book-footer justify-between">
  
  <div>
    
    <a href="https://github.com/computablelabs/compspec/commit/e74a1ab68a380e1682cca35ff064443a013075f5" title='Last modified Aug 22, 2019 by Bharath Ramsundar' target="_blank" rel="noopener">
      <img src="../../svg/calendar.svg" alt="Changed" /> Aug 22, 2019
    </a>
  </div>
  
  
  <div>
    <a href="https://github.com/computablelabs/compspec/edit/master/docs/voting.md" target="_blank" rel="noopener">
      <img src="../../svg/edit.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  

  <aside class="book-toc level-6 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#voting">Voting</a>
<ul>
<li><a href="#candidates-candidates-candidates">Candidates, Candidates, Candidates</a>
<ul>
<li><a href="#listing-candidates">Listing candidates</a></li>
<li><a href="#challenge-candidate">Challenge candidate</a></li>
<li><a href="#reparameterization-candidate">Reparameterization candidate</a></li>
<li><a href="#datatrust-candidate">Datatrust candidate</a></li>
</ul></li>
<li><a href="#the-voting-code">The voting code</a></li>
<li><a href="#voting-1">Voting</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
